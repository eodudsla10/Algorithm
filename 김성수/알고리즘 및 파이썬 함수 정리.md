# 파이썬 알고리즘 및 함수 정리

---

# 알고리즘

## 재귀함수

컴퓨터 내부에서 재귀함수 수행은 스택 자료구조를 이용한다.(스택 라이브러리 대신에 재귀 함수를 이용)

대표적인 예로 

**팩토리얼** 

n! = 1x2x3x...(n-1)xn

```python
def factorial(n):
	if n > 1:
		return 1
	return n * factorial(n-1)
```

**최대 공약수 계산 (유클리드 호제법)**

유클리드 호제법

- 두 자연수 A,B에 대하여(A>B) A를 B로 나눈 나머지를 R이라고 합시다
- 이 때, A 와 B의 최대공약수는 B와 R의 최대공약수와 같습니다.

```python
def gcd(a,b):
	if a%b == 0 :
		return b
	else:
		return gcd(b,a%b)
```

## DFS(Depth-First Search)

 **깊이 우선 탐색**이라고도 부르며 **깊은 부분을 우선적으로 탐색하는 알고리즘**

**Stack** 자료구조를 이용

1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다
2. 스택의 최상단 노드에 반문하지 않은 인접노드가 있으면 그 인접 노드를 스택에 넣고 방문처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에사 최상단 노드를 꺼낸다
3. 2번 과정을 더 이상 수행할 수 없을 때까지 반복한다

간단하게 **재귀함수**를 이용해 탐색

( 가장 작은 값을 우선으로 탐색/방문 한다)

```python
# DFS 매서드 정의
def dfs(graph , v , visited):
    # 현재 노드는 방문 처리
    visited[v] = True
    print(v , end=' ')
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph,i,visited)

# 각 노드가 열결된 정보를 표현 (2차원 리스트)
graph = [
    [],
    [2,3,8],
    [1,7],
    [1,4,5],
    [3,5],
    [3,4],
    [7],
    [2,6,8],
    [1,7]
]

#각 노드가 방문된 정보를 표현 (1차원 리스트)
#index 1번부터 표현하기위해 *9 했다
visited = [False]*9

dfs(graph,1,visited)
>>>1 2 7 6 8 3 4 5
```

### 주로 사용하는 곳

경우의 수를 구하는 문제

## BFS(Breadth First Search)

**너비 우선 탐색**이라고도 부르며, **그래프에서 가까운 노드(간선의 길이가 짧은 노드)부터 우선적으로 탐색**하는 알고리즘 입니다.

**Queue** 자료구조를 이용

1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 합니다
2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리 합니다.
3. 더이상 2번의 과정을 수행할 수 없을 때까지 반복합니다.

간단하게 **queue**에 데이터가 없을 때까지 반복

```python
from collections import deque

def bfs(graph, start ,visited):
    # 큐 구현을 위해 deque 라이브러리 사용
    queue = deque([start])
    # 현재 노드는 방문 처리
    visited[start] = True
    # 큐가 빌 때까지 반복
    while queue:
        v = queue.popleft()
        print(v ,end=' ')
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True

# 각 노드가 열결된 정보를 표현 (2차원 리스트)
graph = [
    [],
    [2,3,8],
    [1,7],
    [1,4,5],
    [3,5],
    [3,4],
    [7],
    [2,6,8],
    [1,7]
]

#각 노드가 방문된 정보를 표현 (1차원 리스트)
#index 1번부터 표현하기위해 *9 했다
visited = [False]*9

bfs(graph, 1, visited)
```

### 주로 사용하는 곳

최단 거리를 구하는 방법

## 선택 정렬

가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두번쨰 데이터와 바꾸느 과정 반복

```python
list = [2,3,1,5,6,8,7,9]

for i in range(len(list)):
	min_idx = i
	for j in range(i+1 , len(list)):
		if list[min_idx] > list[j]:
			min_idx = j
	list[min_idx] , list[j] = list[j] , list[min_idx] #스와프
```

선택 정렬은 정렬 알고리즘에서 비교적 느린편이다. 

## 삽입 정렬

데이터를 하나씩 확인해가며, 각 데이터를 적절한 위치에 삽입하는 방법

방법

1. 삽입정렬은 두 번째 데이터부터 시작

    (첫 번째 데이터는 그 자체로 정렬되어 있다고 판단하기 때문이다)

2. 두 번째 데이터가 첫 번째 데이터보다 크면 스와프를 이용해 왼쪽으로 이동
3. 자기보다 작은 데이터를 만나게 된다면 그 자리에서 멈춤
4. 리스트의 길이 -1 만큼 반복

```python
list = [2,3,1,5,6,8,7,9]

for i in range(1 , len(list)):
	for j in range(i ,0 , -1):
		if list[j] < list[j-1]: # 자기보다 큰 데이터를 만나면 왼쪽으로 한칸 이동
			list[j] , list[j-1] = list[j-1] , list[j]
		else: # 자기보다 작은 데이터를만나면 그 위치에서 멈춤
			break
```

삽입정렬은 선택정렬과 시간 복잡도는 똑같지만 자료의 상태가 대부분 정렬이 되어있다면 선택정렬보다 빠르게 정렬이 가능하다( break를 통해 안의 for문을 실행하지 않기 때문에)

## 😹퀵정렬

기준 데이터를 설정하고 그 **기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는** 방법입니다

일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나입니다.

병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘

가장 기본적인 퀵 정렬은 **첫 번째 데이터를 기준 데이터(Pivot)**로 설정합니다

```python
array = [5,7,9,,0,1,6,3,4,8] 

def quick_sort(array, start, end):
	if start >= end:
		return # 원소가 1개인 경우 종료
	pivot = start
	left = start +1 # 피벗은 첮 번째 원소
	right = end
	while(left < = right):
		# 피벗보다 큰 데이터를 찾을 때까지 반복(오른쪽으로 이동)
		while(left<=end and array[left] <= array[pivot]):
			left +=1
		# 피벗보다 작은 데이터를 찾을 때까지 반복(왼쪽으로 이동)
		while(right > start and array[right] >= array[pivot]):
			right -=1
		if left > right :#엇갈렸다면 작은 데이터와 피벗을 교체 = 분할
			array[right] , array[pivot] = array[pivot] , arrat[right]
		else : # 엇갈리지 않았다면 작은데이터와 큰 데이터를 교체
			array[left], array[right] = array[right] , array[left]
	#분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 퀵정렬 수행(재귀)
	quick_sort(array,start,right-1)
	quick_sort(array,right+1,end)

quick_sort(array , 0 , len(array)-1)
print(array)
```

### 파이썬 스럽게 퀵정렬 표현

```python
def quick_sort(array):
	if len(array) <=1:
		return array
	pivot = array[0]
	tail = array[1:] # 피벗을 제외한 리스트
	
	left_sid = [x for x in tail if x <=pivot] # 분할된 왼쪽 부분
	right_sid = [x for x in tail if x >pivot] # 분할된 오른쪽 부분

	# 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행하고, 전체 리스트 반환
	return quick_sort(left_side) + [pivot] + quick_sort(right_sid)

print(quick_sort(array))
```

## 계수 정렬

**특정한 조건**이 부합할 때만 사용할 수 있지만 **매우 빠르게 동작하는** 정렬 알고리즘입니다

계수정렬은 **데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때** 사용 가능합니다

데이터의 개수가 N, 데이터(양수) 중 최댓값이 K일 때 최악의 경우에도 수행시간 O(N+K)를 보장

각각의 정수가 몇번 등장했는지 카운트를 세는 방법

```python
# 모든 원소의 값이 0보다 크거나 같다고 가정

# 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
# index의 값이 원소의 값과 동일하게
count = [0] * (max(array) +1)

for i in range(len(array)):
	count[array[i]] +=1 # 각데이터에 해당하는 인덱스의 값 증가
 
for i in range(len(count)): # 리스트에 기록된 정렬 정보 확인
	for j in range(count[i]):
		print(i,end=' ')
```

계수정렬은 **동일한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용**할 수 있습니다.

예를들어 성적의 경우 같은 점수를 가진 학생이 많을 수 있으므로 계수정렬이 효과적입니다

단, 계수정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다 

예를들어 가장 데이터의 개수가 100 이하인데 가장 큰 값이 999,999이라면 생성되는 계수정렬의 리스트의 크기는 백만개가 되기 때문에 심각한 비효율성을 초래할 수 있습니다. 

[제목 없음](https://www.notion.so/1c89071a918342d5aeebda463fb9c597)

## 이진 탐색

**순차탐색** :  리스트 안에 있는 특정한 **데이터를 찾기 위해 앞에서부터 데이터를 하나씩 확인**하는 방법

**이진 탐색** : 정렬되어 있는 리스트에서 **탐색 범위를 절반씩 좁혀가며 데이터를 탐색**하는 방법

이진 탐색은 시작점, 끝점, 중간점을 이용하여 탐새 범위를 설정합니다.

```python
# 이진 탐색 소스코드 구현 ( 재귀 함수)
def binary_search(array,target,start,end):
    print(start,end)
    if start > end:
        return None
    mid = (start+end)//2
		## 찾은 경우 간점 인덱스 반환
    if array[mid] == target:
        return mid
		## 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
    if array[mid] > target :
        return binary_search(array,target,start,mid-1)
		## 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
    else:
        return binary_search(array,target,mid+1,end)

array = [1,3,4,5,7,8,12,31,41]
target = 5

print(binary_search(array,target,0,len(array)-1))
```

### 알아두면 좋은 파이썬 함수??

bisect_left(a,x) : 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 왼쪽 **인덱스**를 반환

bisect_right(a,x) : 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 오른쪽 **인덱스를** 반환

```python
from bisect import bisect_left, bisect_right
a = [1,2,3,4,4,8]
x = 4

print(bisect_left(a,x))
print(bisect_right(a,x))

>> 2
>> 4
```

**값이 특정 범위에 속하는 데이터 개수 구하기**

```python
from bisect import bisect_left, bisect_right

def count_by_range(a,left_value,right_value):
	right_index = bisect_right(a,right_value)
	left_index = bisect_left(a,left_value)
	return right_index - left_index
```

### 파라메트릭 서치(Parametric Search)

- **파라메트릭 서치**란 최적화 문제를 결정 문제('예', 혹은 '아니오')로 바꾸어 해결하는 기법입니다.

    ex) 특정한 조건을 만족하는 가장 알맞은 값을 빠르게 찾는 최적화 문제 

- 일반적으로 코딩테스트에서 파라메트릭 서치 문제는 **이진 탐색을 이용**하여 해결 할수 있습니다.

## 다이나믹 프로그래밍(동적 계획법)

- 다이나믹 프로그래밍은 **메모리를 적적히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법**
- 이미 계산된 결과(작은 문제)는 별도의 메모리에 영역에 저장하여 다시 계산하지 않도록 합니다
- 다이나믹 프로그래밍의 구현은 일반적으로 두 가지 방식(**탑다운-위에서 내려가는 방식**과 **보텀업/상향식-아래에서 올라가는**)으로 구성됩니다.
- 일반적인 프로그래밍 분야에서의 동적(Dynamic)이란 어떤 의미일까?
    - 자료구조에서 동적 할당(Dynamic Allocation)은 '**프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법**'을의미합니다.
    - 반면에 **다이나믹 프로그래밍**에서 '다이나믹은' **별다른 의미 없이 사용된 단어** 입니다.
- 다이나믹 프로그래밍은 문제가 다음의 조건을 만족할 때 사용할 수 있습니다.
    1. **최적 부분 구조(Optimal Substructure)**

        큰 문제를 작은문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결 할 수 있습니다.

    2. **중복되는 부분 문제(Overlapping Subproblem)**

        동일한 작은 문제를 반복적으로 해결해야합니다

### 피보나치로 알아보는 다이나믹 프로그래밍

**재귀적으로 표현**

```python
def fibo(x):
	if x == 1 or x == 2 :
		return 1
	return fibo(x-1) + fibo(x-2)

print(fibo(4))
>> 3
```

여기서 문제는 단순 재귀함수로 피보나치 수열을 표현하게 된다면 지수 시간 복잡도를 가지게 됩니다. 즉, **중복되는 함수가 발생**하게 된다.( 효율이 좋지 않다)

그래서 한번 해결한 문제에 대해서는 별도의 메모리 공간에 저장해 사용하는 것이 다이나믹 프로그래밍을 사용한다

피보나치 수열은 다이나믹 프로그래밍의 사용조건을 만족합니다.

이 문제를 해결할 다이나믹 프로그램 방법중 먼저 **하양식에** 대해 알아보자

### 메모이제이션(Memoization)

메모이 제이션은  다이나믹 프로그래밍을 구현하는 방법 중 하나입니다

구현 방법에서 **재귀함수**를 사용

한번 계산한 결과를 메모리 공간에 메모하는 기법

같은 문제를 다시 호출하면 메모했단 결과를 그대로 가져옵니다

값을 기록해 놓는다는 점에서 **캐싱**(Caching)이라고도 합니다

### 탑다운 VS 보텀업

탑다운(메모이제이션) 방식은 **하향식**이라고도 하며 보텀업 방식은 **상향식**이라고도 합니다.

다이나믹 프로그래밍의 전형적인 형태는 **보텀업 방식입니다.**

- 결과 저장용 리스트는 **DP 테이블**이라고 부릅니다.

엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미합니다.

- 따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아닙니다.
- 한번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있습니다.

### 피보나치 수열 : 탑다운 다이나믹 프로그래밍 기법

```python
# 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
d = [0]*100

def fibo(x):
	# 종료 조건 (1 혹은 2일 때 1을 반환)
	if x == 1 or x == 2 :
		return 1
	# 이미 계산한 적 있는 문제라면 그대로 반환
	if d[x] !=0:
		return d[x]
	# 아직 계산하지 않은 문제라면 접화식에 따라서 피보나치 결과 반환
	d[x] = fibo(d[x-1]) + fibo(d[x-2])
	return d[x]

print(fibo(99))
```

### 피보나치 수열 : 보텀업 다이나믹 프로그래밍 기법

```python
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

#첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1 
d[2] = 2

# 피보나치 함수 반복문으로 구현(보텀업 다이나믹 프로그래밍)
for i in range(3 , n-1):
	d[i] = d[i-1] + d[i-2]

print(d[n])
```

### 다이나믹 프로그래밍과 분할 정복의 차이점

다이나믹 프로그래밍은 부분문제가 중복되는 반면

분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않습니다.

# 자료구조

## Stack

파이썬에서는 list로 표현 가능

후입 선출 / 선입 후출 

상자를 쌓는 것과 일치

```python
stack = []
stack.append(1) # 삽입
stack.append(2)
stack.pop() # 추출
stack.append(4)

print(stack)
>>> [1,4]
```

## Queue = deque()

선입 선출 (FIFO - First in First out)

파이썬에서는 list로도 Queue를 구현 가능하지만 시간 복잡도가 높기 때문에 

deque 라이브러리를 사용해서 Queue를 구현하는게 좋다

```python
from collections import deque

queue = deque()
queue.append(5) # 삽입
queue.append(2)
queue.append(3)
queue.append(7)
queue.popleft() # 삭제

print(queue)
>>> [2,3,7]
```

# 파이썬 유용한 함수

## 몫과 나머지 한번에 구하기

### divmod(n , r)

return 값은 tuple형태

q, a = divmod(n , r ) 

q : 몫

a : 나머지

ex)

```python
n = 15
r = 4
print(divmod(n,r)
>>>(3,3)
```

## 절대값 구하기

### abs(a)

음수 a 를 양수 a로 변환 

ex) 

```python
a = -2
c = abs(a)
print( c )
>>> 2
```

## 두개의 리스트 같이 for 돌리기

### for l1, l2 in zip(list1,list2):

두개의 리스트중 길이가 작은 리스트 기준으로 반복

## 리스트 정렬(크기 순으로) sorted(list)

```python
list2 = sorted(list1) 
```

## 리스트 거꾸로 출력 ( Stack에서 많이 사용)

```python
stack = [::-1]
```